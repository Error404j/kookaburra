{"name":"Kookaburra","tagline":"A Ruby framework for implementing the Window Driver testing pattern","body":"# Kookaburra #\r\n\r\nKookaburra is a framework for implementing the [Window Driver] [Window Driver]\r\npattern in order to keep acceptance tests maintainable.\r\n\r\n[![Code Climate](https://codeclimate.com/github/jwilger/kookaburra/badges/gpa.svg)](https://codeclimate.com/github/jwilger/kookaburra)\r\n[![Test Coverage](https://codeclimate.com/github/jwilger/kookaburra/badges/coverage.svg)](https://codeclimate.com/github/jwilger/kookaburra)\r\n\r\n## Requirements ##\r\n\r\nRequires Ruby 2.1.0 or greater.\r\n\r\n## Installation ##\r\n\r\nKookaburra is available as a Rubygem and\r\n[published on Rubygems.org] [Kookaburra Gem], so installation is trivial:\r\n\r\n    gem install kookaburra\r\n\r\nIf you're using [Bundler](http://gembundler.com/) for your project, just add the\r\nfollowing:\r\n\r\n    group :development, :test do\r\n      gem 'kookaburra'\r\n    end\r\n\r\n## Setup ##\r\n\r\nKookaburra abstracts some common patterns for implementing the Window\r\nDriver testing pattern for web applications. You will need to tell\r\nKookaburra which classes contain the specific Domain Driver\r\nimplementations for your application as well as which driver to use for\r\nrunning the tests (currently only tested with [Capybara] [Capybara]).\r\n\r\nKookaburra is designed to run tests against one or more remote web\r\nservers (although the server(s) could be running on the same machine, it\r\ndoesn't need to be), and it is the responsibility of the test\r\nimplementation to ensure that the server is running. \r\n\r\nThe fact that Kookaburra runs against a remote server means that *it is\r\nnot limited to testing only Ruby web applications*. As long as your\r\napplication exposes a web-service API for use by the APIDriver and an\r\nHTML user interface for use by the UIDriver, you can use Kookaburra to\r\ntest it. Also, as long as you're careful with both your application and\r\ntest designs, you're not limited to running your tests only in an\r\nisolated testing environment; you could run the same test suite you use\r\nfor development against your staging or production systems.\r\n\r\n### Testing an Application Running Locally ###\r\n\r\nThe fact that Kookaburra is designed to support running tests against a\r\nremote server does not, of course, mean that the application cannot be\r\nrunning locally.  It is possible to have your test suite manage the\r\nprocess of starting and stopping your server(s) for you. Examples of how\r\nto do so with a Rack application are presented below, but you should be\r\nable to take the same basic approach with other types of application\r\nservers.\r\n\r\nAlthough Capybara is capable of starting a Rack application server on\r\nits own, the default setup only starts the server up on-demand when you\r\ncall a method that requires the browser to interact with the web\r\napplication. Because the APIClient layer does not use Capybara, it is\r\nnecessary to manage the server process on your own. Otherwise the server\r\nwould not be guaranteed to be running when you call the APIClient\r\nmethods (particularly as these often appear in \"Given\" statements that\r\nare run before you start interacting with the web browser.)\r\n\r\n**Keep in mind that, even if your server is capable of being started up in\r\nanother thread within the same Ruby process that is executing your test\r\nsuite, you will want to avoid doing so unless you are using a Ruby\r\ninterpreter that supports native threads. Otherwise, when the APIClient\r\nmakes an HTTP call to your application's API, it will block while\r\nwaiting for a response, thus preventing your application from being able\r\nto respond to that request and resulting in a timeout error in your\r\ntests.**\r\n\r\n### RSpec ###\r\n\r\nThe following examples depict how you might configure RSpec to run tests against\r\nan already running application server (e.g. a remote staging site) and a Rack\r\napplication server that is managed by the test suite.\r\n\r\n#### Testing an already running server ####\r\n\r\nIf you are running your tests against an already running server, you can simply\r\nadd the following to `spec/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # c.app_host below should be set to whatever the root URL of your running\r\n    # application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://my_app.example.com:1234'\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    RSpec.configure do |c|\r\n      # Makes the #k, #api and #ui methods available to your specs\r\n      # (See section on test implementation below)\r\n      c.include(Kookaburra::TestHelpers, :type => :request)\r\n    end\r\n\r\n#### Testing Multiple Applications\r\n\r\nSometimes you need to test a business process that spans multiple\r\n\"applications\" in your platform. Kookaburra can be configured to operate\r\nagainst multiple remote applications by defining them in the\r\nconfiguration block as follows:\r\n\r\n    Kookaburra.configure do |c|\r\n      c.application(:app_one) do |a|\r\n        a.api_driver_class = AppOne::APIDriver\r\n        a.ui_driver_class = AppOne::UIDriver\r\n        a.app_host = 'http://app_one.example.com:1234'\r\n      end\r\n\r\n      c.application(:app_two) do |a|\r\n        a.api_driver_class = AppTwo::APIDriver\r\n        a.ui_driver_class = AppTwo::UIDriver\r\n        a.app_host = 'http://app_two.example.com:1234'\r\n      end\r\n\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\nThis changes the way you use the `#api` and `#ui` test helpers\r\n(explained below) so that you must qualify each one with the name of the\r\napplication, i.e. `#app_one.api`, and `#app_two.ui`. Configuration\r\nparameters set on the base configuration (e.g. `c.browser = #...`) are\r\nshared between all named applications that do not specifically override\r\nthem.\r\n\r\n#### Managing startup and shutdown of a Rack application server ####\r\n\r\nWhile developing, it can be helpful to run your integration specs\r\nagainst a locally-running server that is managed by your test suite. The\r\nsetup is similar to that in the previous section, but it adds before and\r\nafter hooks to launch and shut down a Rack application server. Just add\r\nthe following to `spec/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n    require 'kookaburra/rack_app_server'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # `MyApplication` below should be replaced with the object that\r\n    # implements the Rack `#call` interface for your application. For a\r\n    # Rails app, this would be along the lines of\r\n    # `MyAppName::Application`.\r\n    app_server = Kookaburra::RackAppServer.new do\r\n      require 'path/to/my_application'\r\n      MyApplication\r\n    end\r\n\r\n    # c.app_host below should be set to whatever the root URL of your\r\n    # running application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://localhost:%d' % app_server.port\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    RSpec.configure do |c|\r\n      c.include(Kookaburra::TestHelpers, :type => :request)\r\n\r\n      c.before(:all, :type => :request) do\r\n        app_server.boot\r\n      end\r\n\r\n      c.after(:all, :type => :request) do\r\n        app_server.shutdown\r\n      end\r\n    end\r\n\r\n### Cucumber ###\r\n\r\nThe following examples depict how you might configure [Cucumber]\r\n[Cucumber] to run tests against an already running application server\r\n(e.g. a remote staging site) and a Rack application server that is\r\nmanaged by the test suite.\r\n\r\n#### Testing an already running server ####\r\n\r\nIf you are running your tests against an already running server, you can\r\nsimply add the following to `features/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # c.app_host below should be set to whatever the root URL of your running\r\n    # application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://my_app.example.com:1234'\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    World(Kookaburra::TestHelpers)\r\n\r\n#### Testing Multiple Applications\r\n\r\nSometimes you need to test a business process that spans multiple\r\n\"applications\" in your platform. Kookaburra can be configured to operate\r\nagainst multiple remote applications by defining them in the\r\nconfiguration block as follows:\r\n\r\n    Kookaburra.configure do |c|\r\n      c.application(:app_one) do |a|\r\n        a.api_driver_class = AppOne::APIDriver\r\n        a.ui_driver_class = AppOne::UIDriver\r\n        a.app_host = 'http://app_one.example.com:1234'\r\n      end\r\n\r\n      c.application(:app_two) do |a|\r\n        a.api_driver_class = AppTwo::APIDriver\r\n        a.ui_driver_class = AppTwo::UIDriver\r\n        a.app_host = 'http://app_two.example.com:1234'\r\n      end\r\n\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\nThis changes the way you use the `#api` and `#ui` test helpers\r\n(explained below) so that you must qualify each one with the name of the\r\napplication, i.e. `#app_one.api`, and `#app_two.ui`. Configuration\r\nparameters set on the base configuration (e.g. `c.browser = #...`) are\r\nshared between all named applications that do not specifically override\r\nthem.\r\n\r\n#### Managing startup and shutdown of a Rack application server ####\r\n\r\nWhile developing, it can be helpful to run your acceptance tests against\r\na locally-running server that is managed by your test suite. The setup\r\nis similar to that in the previous section, but it adds before and after\r\nhooks to launch and shut down a Rack application server. Just add the\r\nfollowing to `features/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n    require 'kookaburra/rack_app_server'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # `MyApplication` below should be replaced with the object that\r\n    # implements the Rack `#call` interface for your application. For a\r\n    # Rails app, this would be along the lines of\r\n    # `MyAppName::Application`.\r\n    app_server = Kookaburra::RackAppServer.new do\r\n      require 'path/to/my_application'\r\n      MyApplication\r\n    end\r\n\r\n    # c.app_host below should be set to whatever the root URL of your\r\n    # running application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://localhost:%d' % app_server.port\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    World(Kookaburra::TestHelpers)\r\n\r\n    app_server.boot\r\n\r\n    at_exit do\r\n      app_server.shutdown\r\n    end\r\n\r\n## Defining Your Testing DSL ##\r\n\r\nKookaburra extracts some common patterns that make it easier to use the\r\nWindow Driver pattern along with various Ruby testing frameworks, but\r\nyou still need to define your own testing DSL. An acceptance testing\r\nstack using Kookaburra has the following layers:\r\n\r\n1. The **Business Specification Language** (Cucumber scenarios or other\r\n   spcification documents)\r\n2. The **Test Implementation** (Cucumber step definitions, RSpec example blocks,\r\n   etc.)\r\n3. The **Domain Driver** (Kookaburra::APIDriver and Kookaburra::UIDriver)\r\n4. The **Window Driver** (Kookaburra::UIDriver::UIComponent)\r\n5. The **Application Driver** (Capybara and Kookaburra::APIClient)\r\n\r\n### The Business Specification Language ###\r\n\r\nThe business specification language consists of the highest-level\r\ndescriptions of a feature that are suitable for sharing with the\r\nnon/less-technical stakeholders on a project.\r\n\r\nGherkin is the external DSL used by Cucumber for this purpose, and you\r\nmight have the following scenario defined for an e-commerce application:\r\n\r\n    # purchase_items_in_cart.feature\r\n\r\n    Feature: Purchase Items in Cart\r\n\r\n      Scenario: Using Existing Billing and Shipping Information\r\n\r\n        Given I have an existing account\r\n        And I have previously specified default payment options\r\n        And I have previously specified default shipping options\r\n        And I have an item in my shopping cart\r\n\r\n        When I sign in to my account\r\n        And I choose to check out\r\n\r\n        Then I see my order summary\r\n        And I see that my default payment options will be used\r\n        And I see that my default shipping options will be used\r\n\r\nNote that the scenario is focused on business concepts versus interface\r\ndetails, i.e. you \"choose to check out\" rather than \"click on the\r\ncheckout button\". If for some reason your e-commerce system was going to\r\nbe a terminal application rather than a web application, you would not\r\nneed to change this scenario at all, because the actual business\r\nconcepts described would not change (and although Kookaburra's focus is\r\non testing web applications, it could likely be adapted to other\r\nenvironments.)\r\n\r\n### The Test Implementation ###\r\n\r\nThe Test Implementation layer exists as the line in between the Business\r\nSpecification Language and the Domain Driver, and it includes Cucumber\r\nstep definitions, RSpec example blocks, Test::Unit tests, etc. At this\r\nlayer, your code orchestrates calls into the Domain Driver to mimic user\r\ninteractions under various conditions and make assertions about the\r\nresults.\r\n\r\n**Test assertions always belong within the test implementation layer.**\r\nSome testing frameworks such as RSpec add methods like `#should` to\r\n`Object`, which has the effect of poisoning the entire Ruby namespace\r\nwith these methods---if you are using RSpec, you can call `#should`\r\nanywhere in your code and it will work when RSpec is loaded. Do not be\r\ntempted to call a testing library's Object decorators anywhere outside\r\nof your test implementation (such as within `UIDriver` or `UIComponent`\r\nsubclasses.) Doing so will tightly couple your Domain Driver and/or\r\nWindow Driver implementation to a specific testing library.\r\n\r\n`Kookaburra::UIDriver::UIComponent` provides an `#assert` method for use\r\ninside your own UIComponents. This method exists to verify preconditions\r\nand provide more informative error messages; it is not intended to be\r\nused for test verifications.\r\n\r\nGiven the Cucumber scenario above, here is how the test implementation layer\r\nmight look:\r\n\r\n    # step_definitions/various_steps.rb\r\n\r\n    Given \"I have an existing account\" do\r\n      api.existing_account\r\n    end\r\n\r\n    Given \"I have previously specified default payment options\" do\r\n      api.default_payment_options_specified\r\n    end\r\n\r\n    Given \"I have previously specified default shipping options\" do\r\n      api.default_shipping_options_specified\r\n    end\r\n\r\n    Given \"I have an item in my shopping cart\" do\r\n      api.an_item_in_my_shopping_cart\r\n    end\r\n\r\n    When \"I sign in to my account\" do\r\n      ui.sign_in\r\n    end\r\n\r\n    When \"I choose to check out\" do\r\n      ui.choose_to_check_out\r\n    end\r\n\r\n    Then \"I see my order summary\" do\r\n      ui.order_summary.should be_visible\r\n    end\r\n\r\n    Then \"I see that my default payment options will be used\" do\r\n      expect(ui.order_summary.payment_options).to \\\r\n        eq get_data(:payment_optons)[:default]\r\n    end\r\n\r\n    Then \"I see that my default shipping options will be used\" do\r\n      expect(ui.order_summary.shipping_options).to \\\r\n        eq get_data(:shipping_options)[:default]\r\n    end\r\n\r\nThe step definitions contain neither explicitly shared state (instance\r\nvariables) nor any logic branches; they are simply wrappers around calls\r\ninto the Domain Driver layer. There are a couple of advantages to this\r\napproach.\r\n\r\nFirst, because step definitions are so simple, it isn't necessary to\r\nforce *Very Specific Wording* on the business analyst/product owner who\r\nis writing the specs. For instance, if she writes \"I see a summary of my\r\norder\" in another scenario, it's not a big deal to have the following in\r\nyour step definitions (as long as the author of the spec confirms that\r\nthey really mean the same thing):\r\n\r\n    Then \"I see my order summary\" do\r\n      ui.order_summary.should be_visible\r\n    end\r\n\r\n    Then \"I see a summary of my order\" do\r\n      ui.order_summary.should be_visible\r\n    end\r\n\r\nThe step definitions are nothing more than a natural language reference\r\nto an action in the Domain Driver; there is no overwhelming maintenance\r\ncost to the slight duplication, and it opens up the capacity for more\r\nreadable Gherkin specs. The fewer false road blocks you put between your\r\nproduct owner and a written specification, the easier it becomes to\r\nensure her participation in this process.\r\n\r\nThe second advantage is that by pushing all of the complexity down into\r\nthe Domain Driver, it's now trivial to reuse the exact same code in\r\ndeveloper-centric integration tests. This ensures you have parity\r\nbetween the way the automated acceptance tests run and any additional\r\ntesting that the development team needs to add in.\r\n\r\nUsing RSpec, the test implementation would be as follows:\r\n\r\n    # spec/integration/purchase_items_in_cart_spec.rb\r\n    \r\n    describe \"Purchase Items in Cart\" do\r\n      example \"Using Existing Billing and Shipping Information\" do\r\n        api.existing_account(:my_account)\r\n        api.default_payment_options_specified\r\n        api.default_shipping_options_specified\r\n        api.an_item_in_my_shopping_cart\r\n\r\n        ui.sign_in\r\n        ui.choose_to_check_out\r\n\r\n        expect(ui.order_summary).to be_visible\r\n        expect(ui.order_summary.payment_options).to \\\r\n          eq get_data(:payment_optons)[:default]\r\n\r\n        expect(ui.order_summary.shipping_options).to \\\r\n          eq get_data(:shipping_options)[:default]\r\n      end\r\n    end\r\n\r\n### The Domain Driver ###\r\n\r\nThe Domain Driver layer is where you build up an internal DSL that\r\ndescribes the business concepts of your application at a fairly high\r\nlevel. It consists of two top-level drivers: the `APIDriver` (available\r\nvia `#api`) used to set up state for your tests and the UIDriver\r\n(available via `#ui`) for describing the tasks that a user can\r\naccomplish with the application.\r\n\r\n#### Mental Model ####\r\n\r\n`Kookaburra::MentalModel` is the component via which the `APIDriver` and\r\nthe `UIDriver` share information, and it is intended to represent your\r\napplication user's mental picture of the data they are working with. For\r\ninstance, if you create a user account via the `APIDriver`, you would\r\nstore the login credentials for that account in the `MentalModel`\r\ninstance, so the `UIDriver` knows what to use when you tell it to\r\n`#sign_in`. This is what allows the Cucumber step definitions to remain\r\nfree from explicitly shared state.\r\n\r\nKookaburra automatically configures your `APIDriver` and your `UIDriver`\r\nto share a `MentalModel` instance, which is available to both of them\r\nvia their `#mental_model` method.\r\n\r\nThe `MentalModel` instance will return a `MentalModel::Collection` for\r\nany method called on the object. The `MentalModel::Collection` object\r\nbehaves like a `Hash` for the most part; however, it will raise a\r\n`Kookaburra::UnknownKeyError` if you try to access a key that has not\r\nyet been assigned a value.\r\n\r\nDeletions (via `#delete` or `#delete_if`) will actually remove the\r\nkey/value pair from the collection, but add it to a sub-collection\r\n(available at `MentalModel::Collection#deleted`). This reflects the fact\r\nthat the user's mental model of the dataset would also include any\r\nintentional exceptions - the user will, for example, want to verify that\r\nan item they deleted does not appear to be available in the system.\r\n\r\nHere's an example of MentalModel behavior:\r\n\r\n    mental_model = MentalModel.new\r\n\r\n    mental_model.widgets[:widget_a] = {'name' => 'Widget A'}\r\n\r\n    mental_model.widgets[:widget_a]\r\n    #=> {'name' => 'Widget A'}\r\n\r\n    # this will raise a Kookaburra::UnknownKeyError\r\n    mental_model.widgets[:widget_b]\r\n\r\n    mental_model.widgets.delete(:widget_a)\r\n    #=> {'name' => 'Widget A'}\r\n\r\n    # this will now also raise a Kookaburra::UnknownKeyError...\r\n    mental_model.widgets[:widget_a]\r\n\r\n    # ...but the pair is now available here:\r\n    mental_model.widgets.deleted[:widget_a]\r\n    #=> {'name' => 'Widget A'}\r\n\r\n#### API Driver ####\r\n\r\nThe `Kookaburra::APIDriver` is used to create a particular \"preexisting\"\r\nstate within your application's data and ensure you have a handle to\r\nthat data (when needed) prior to interacting with the UI. You will\r\ncreate a subclass of `Kookaburra::APIDriver` in which you will create\r\npart of the Domain Driver DSL for your application:\r\n\r\n    # lib/my_app/kookaburra/api_driver.rb\r\n\r\n    class MyApp::Kookaburra::APIDriver < Kookaburra::APIDriver\r\n      # Specify the APIClient to use\r\n      def api\r\n        @api ||= MyApp::Kookaburra::APIClient.new(configuration)\r\n      end\r\n\r\n      def existing_account(nickname)\r\n        account_data = {'display_name' => 'John Doe', 'password' => 'a password'}\r\n        account_data['username'] = \"test-user-#{`uuidgen`.strip}\"\r\n\r\n        # use the API to create the account in the application\r\n        result = api.create_account(account_data)\r\n\r\n        # merge in the password, since API (hopefully!) doesn't return it, and\r\n        # store details in the MentalModel instance\r\n        result.merge!('password' => account_data['password'])\r\n        mental_model.accounts[nickname] = account_details\r\n      end\r\n    end\r\n\r\n#### API Client ####\r\n\r\nThe `Kookaburra::APIClient` is used to interact with an application's\r\nexternal web services API. You tell Kookaburra about your API by\r\ncreating a subclass of `Kookaburra::APIClient` for your application,\r\nspecifying how requests should be encoded and decoded, and specifying\r\nany headers that should be present on every request.\r\n\r\n    # lib/my_app/kookaburra/api_driver.rb\r\n\r\n    class MyApp::Kookaburra::APIClient < Kookaburra::APIClient\r\n      encode_with { |data| JSON.dump(data) }\r\n      decode_with { |data| JSON.parse(data) }\r\n      header 'Content-Type', 'application/json'\r\n      header 'Accept', 'application/json'\r\n\r\n      def create_account(account_data)\r\n        post '/api/accounts', account_data\r\n      end\r\n\r\n      def get_account(id)\r\n        get '/api/accounts/%d' % id\r\n      end\r\n    end\r\n\r\nThe content of your application's APIClient should consist mainly of\r\nmappings between discrete actions and HTTP requests to the specified URL\r\npaths.\r\n\r\n#### UI Driver ####\r\n\r\n`Kookaburra::UIDriver` provides the necessary tools for driving your\r\napplication's user interface with the Window Driver pattern. You will\r\nsubclass `Kookaburra::UIDriver` for your application and implement your\r\ntesting DSL within your subclass:\r\n\r\n    # lib/my_app/kookaburra/ui_driver.rb\r\n\r\n    class MyApp::Kookaburra::UIDriver < Kookaburra::UIDriver\r\n      # makes an instance of MyApp::Kookaburra::UIDriver::SignInScreen\r\n      # available via the instance method #sign_in_screen\r\n      ui_component :sign_in_screen, SignInScreen\r\n\r\n      def sign_in(account_nickname)\r\n        account = mental_model.accounts[account_nickname]\r\n        address_bar.go_to(sign_in_screen)\r\n        sign_in_screen.submit_login(account['username'], account['password'])\r\n      end\r\n    end\r\n\r\n### The Window Driver Layer ###\r\n\r\nWhile your `APIDriver` and `UIDriver` provide a DSL that represents\r\nactions your users can perform in your application, the\r\n[Window Driver] [Window Driver] layer describes the individual user\r\ninterface components that the user interacts with to perform these\r\ntasks. By describing each interface component using an OOP approach, it\r\nis much easier to maintain your acceptance/integration tests, because\r\nthe implementation details of each component are captured in a single\r\nplace. For example, if/when the implementation of your application's\r\nsign in screen changes, you can fix every single test that needs to log\r\na user into the system just by updating the `SignInScreen` class.\r\n\r\nYou describe the various user interface components by sub-classing\r\n`Kookaburra::UIDriver::UIComponent`:\r\n\r\n    # lib/my_app/ui_driver/sign_in_screen.rb\r\n\r\n    class MyApp::Kookaburra::UIDriver::SignInScreen < Kookaburra::UIDriver::UIComponent\r\n      def component_locator\r\n        '#new_user_session'\r\n      end\r\n\r\n      def component_path\r\n        '/session/new'\r\n      end\r\n\r\n      def username\r\n        find('#session_username').value\r\n      end\r\n\r\n      def username=(new_value)\r\n        fill_in '#session_username', :with => new_value\r\n      end\r\n\r\n      def password\r\n        find('#session_password').value\r\n      end\r\n\r\n      def password=(new_value)\r\n        fill_in '#session_password', :with => new_value\r\n      end\r\n\r\n      def submit\r\n        click_on('Sign In')\r\n      end\r\n\r\n      def submit_login(username, password)\r\n        self.username = username\r\n        self.password = password\r\n        submit\r\n      end\r\n    end\r\n\r\n### The Application Driver Layer ###\r\n\r\n`Kookaburra::APIClient`, `Kookaburra::UIDriver` and\r\n`Kookaburra::UIDriver::UIComponent` rely on the Application Driver layer\r\nto interact with your application. In the case of the `APIClient`,\r\nKookaburra uses the [RestClient] [RestClient] library to send HTTP\r\nrequests to your application. The `UIDriver` and `UIComponent` rely on\r\nwhatever is passed to `Kookaburra.new` as the `:browser` option.\r\nPresently, we have only used Capybara as the application driver for\r\nKookaburra.\r\n\r\nIt's possible that something other than Capybara could be passed in, as\r\nlong as that something presented the same API. In reality, using\r\nsomething other than Capybara is likely to require some changes to\r\nKookaburra itself. If you have a particular interest in making this\r\nwork, please feel free to fork the project and send us a [GitHub pull\r\nrequest] [Pull Request] with your changes.\r\n\r\n## Contributing to kookaburra ##\r\n \r\n* Check out the latest master to make sure the feature hasn't been implemented\r\n  or the bug hasn't been fixed yet\r\n* Check out the issue tracker to make sure someone already hasn't requested it\r\n  and/or contributed it\r\n* Fork the project\r\n* Start a feature/bugfix branch\r\n* Commit and push until you are happy with your contribution\r\n* Make sure to add tests for it. This is important so I don't break it in a\r\n  future version unintentionally.\r\n* Please try not to mess with the Rakefile, version, or history. If you want to\r\n  have your own version, or is otherwise necessary, that is fine, but please\r\n  isolate to its own commit so I can cherry-pick around it.\r\n* Send us a [pull request] [Pull Request]\r\n\r\n## Copyright ##\r\n\r\nCopyright &copy; 2011 John Wilger. See LICENSE.txt for further details.\r\n\r\n[Window Driver]: http://martinfowler.com/eaaDev/WindowDriver.html \"Window Driver - Martin Fowler\"\r\n[Kookaburra Gem]: https://rubygems.org/gems/kookaburra \"kookaburra | RubyGems.org | your community gem host\"\r\n[Rack]: http://rack.rubyforge.org/ \"Rack: a Ruby Webserver Interface\"\r\n[Capybara]: https://github.com/jnicklas/capybara \"jnicklas/capybara - GitHub\"\r\n[RSpec]: http://rspec.info \"RSpec.info: home\"\r\n[Cucumber]: http://cukes.info/ \"Cucumber - Making BDD fun\"\r\n[Pull Request]: https://github.com/projectdx/kookaburra/pull/new/master \"Send a pull request - GitHub\"\r\n[RestClient]: https://github.com/archiloque/rest-client \"archiloque/rest-client -GitHub\"\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}