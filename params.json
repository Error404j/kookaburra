{"name":"Kookaburra","tagline":"A Ruby framework for implementing the Window Driver testing pattern","body":"# Kookaburra #\r\n\r\nKookaburra is a framework for implementing the [Window Driver] [Window Driver] pattern in\r\norder to keep acceptance tests maintainable.\r\n\r\n## Requirements ##\r\n\r\nRequires Ruby 1.9.3 or greater. Tested with both MRI and JRuby (note \r\nthat you must run JRuby in 1.9 compatability mode.)\r\n\r\n## Installation ##\r\n\r\nKookaburra is available as a Rubygem and [published on Rubygems.org] [Kookaburra Gem],\r\nso installation is trivial:\r\n\r\n    gem install kookaburra\r\n\r\nIf you're using [Bundler](http://gembundler.com/) for your project, just add the\r\nfollowing:\r\n\r\n    group :development, :test do\r\n      gem 'kookaburra'\r\n    end\r\n\r\n## Setup ##\r\n\r\nKookaburra abstracts some common patterns for implementing the Window Driver\r\ntesting pattern for web applications. You will need to tell Kookaburra which\r\nclasses contain the specific Domain Driver implementations for your application\r\nas well as which driver to use for running the tests (currently only tested with\r\n[Capybara] [Capybara]).\r\n\r\nKookaburra is designed to run tests agains a remote web server (although that\r\nserver could be running on the same machine, it doesn't need to be), and it is\r\nthe responsibility of the test implementation to ensure that the server is\r\nrunning. \r\n\r\nThe fact that Kookaburra runs against a remote server means that *it is not\r\nlimited to testing only Ruby web applications*. As long as your application\r\nexposes a web-service API for use by the APIDriver and an HTML user interface\r\nfor use by the UIDriver, you can use Kookaburra to test it. Also, as long as\r\nyou're careful with both your application and test designs, you're not limited\r\nto running your tests only in an isolated testing environment; you could run\r\nthe same test suite you use for development against your staging or production\r\nsystems.\r\n\r\n### Testing an Application Running Locally ###\r\n\r\nThe fact that Kookaburra is designed to support running tests against a remote\r\nserver does not, of course, mean that the application cannot be running locally.\r\nIt is possible to have your test suite manage the process of starting and\r\nstopping your server for you. Examples of how to do so with a Rack application\r\nare presented below, but you should be able to take the same basic approach with\r\nother types of application servers.\r\n\r\nAlthough Capybara is capable of starting a Rack application server on \r\nits own, the default setup only starts the server up on-demand when you \r\ncall a method that requires the browser to interact with the web \r\napplication. Because the APIClient layer does not use Capybara, it is \r\nnecessary to manage the server process on your own. Otherwise the server \r\nwould not be guaranteed to be running when you call the APIClient \r\nmethods (particularly as these often appear in \"Given\" statements that \r\nare run before you start interacting with the web browser.)\r\n\r\nKeep in mind that, even if your server is capable of being started up in another\r\nthread within the same Ruby process that is executing your test suite, you will\r\nwant to avoid doing so unless you are using a Ruby interpreter that supports\r\nnative threads. Otherwise, when the APIClient makes an HTTP call to your\r\napplication's API, it will block while waiting for a response, thus preventing\r\nyour application from being able to respond to that request and resulting in a\r\ntimeout error in your tests.\r\n\r\n### RSpec ###\r\n\r\nThe following examples depict how you might configure RSpec to run tests against\r\nan already running application server (e.g. a remote staging site) and a Rack\r\napplication server that is managed by the test suite.\r\n\r\n#### Testing an already running server ####\r\n\r\nIf you are running your tests against an already running server, you can simply\r\nadd the following to `spec/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # c.app_host below should be set to whatever the root URL of your running\r\n    # application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://my_app.example.com:1234'\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    RSpec.configure do |c|\r\n      # Makes the #k, #api and #ui methods available to your specs\r\n      # (See section on test implementation below)\r\n      c.include(Kookaburra::TestHelpers, :type => :request)\r\n    end\r\n\r\n#### Managing startup and shutdown of a Rack application server ####\r\n\r\nWhile developing, it can be helpful to run your integration specs against a\r\nlocally-running server that is managed by your test suite. The setup is similar\r\nto that in the previous section, but it adds before and after hooks to launch\r\nand shut down a Rack application server. Just add the following to\r\n`spec/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n    require 'kookaburra/rack_app_server'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # `MyApplication` below should be replaced with the object that\r\n    # implements the Rack `#call` interface for your application. For a\r\n    # Rails app, this would be along the lines of\r\n    # `MyAppName::Application`.\r\n    app_server = Kookaburra::RackAppServer.new do\r\n      require 'path/to/my_application'\r\n      MyApplication\r\n    end\r\n\r\n    # c.app_host below should be set to whatever the root URL of your\r\n    # running application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://localhost:%d' % app_server.port\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    RSpec.configure do |c|\r\n      c.include(Kookaburra::TestHelpers, :type => :request)\r\n\r\n      c.before(:all, :type => :request) do\r\n        app_server.boot\r\n      end\r\n\r\n      c.after(:all, :type => :request) do\r\n        app_server.shutdown\r\n      end\r\n    end\r\n\r\n### Cucumber ###\r\n\r\nThe following examples depict how you might configure [Cucumber] [Cucumber] to\r\nrun tests against an already running application server (e.g. a remote staging\r\nsite) and a Rack application server that is managed by the test suite.\r\n\r\n#### Testing an already running server ####\r\n\r\nIf you are running your tests against an already running server, you can simply\r\nadd the following to `features/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # c.app_host below should be set to whatever the root URL of your running\r\n    # application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://my_app.example.com:1234'\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    World(Kookaburra::TestHelpers)\r\n\r\n#### Managing startup and shutdown of a Rack application server ####\r\n\r\nWhile developing, it can be helpful to run your acceptance tests against a\r\nlocally-running server that is managed by your test suite. The setup is similar\r\nto that in the previous section, but it adds before and after hooks to launch\r\nand shut down a Rack application server. Just add the following to\r\n`features/support/kookaburra_setup.rb`:\r\n\r\n    require 'kookaburra/test_helpers'\r\n    require 'kookaburra/rack_app_server'\r\n\r\n    # Change these to the files that define your custom APIDriver and UIDriver\r\n    # implementations.\r\n    require 'my_app/kookaburra/api_driver'\r\n    require 'my_app/kookaburra/ui_driver'\r\n\r\n    # `MyApplication` below should be replaced with the object that\r\n    # implements the Rack `#call` interface for your application. For a\r\n    # Rails app, this would be along the lines of\r\n    # `MyAppName::Application`.\r\n    app_server = Kookaburra::RackAppServer.new do\r\n      require 'path/to/my_application'\r\n      MyApplication\r\n    end\r\n\r\n    # c.app_host below should be set to whatever the root URL of your\r\n    # running application is.\r\n    Kookaburra.configure do |c|\r\n      c.api_driver_class = MyApp::Kookaburra::APIDriver\r\n      c.ui_driver_class = MyApp::Kookaburra::UIDriver\r\n      c.app_host = 'http://localhost:%d' % app_server.port\r\n      c.browser = Capybara::Session.new(:selenium)\r\n      c.server_error_detection { |browser|\r\n        browser.has_css?('head title', :text => 'Internal Server Error')\r\n      }\r\n    end\r\n\r\n    World(Kookaburra::TestHelpers)\r\n\r\n    app_server.boot\r\n\r\n    at_exit do\r\n      app_server.shutdown\r\n    end\r\n\r\n## Defining Your Testing DSL ##\r\n\r\nKookaburra extracts some common patterns that make it easier to use the Window\r\nDriver pattern along with various Ruby testing frameworks, but you still need to\r\ndefine your own testing DSL. An acceptance testing stack using Kookaburra has\r\nthe following layers:\r\n\r\n1. The **Business Specification Language** (Cucumber scenarios or other\r\n   spcification documents)\r\n2. The **Test Implementation** (Cucumber step definitions, RSpec example blocks,\r\n   etc.)\r\n3. The **Domain Driver** (Kookaburra::APIDriver and Kookaburra::UIDriver)\r\n4. The **Window Driver** (Kookaburra::UIDriver::UIComponent)\r\n5. The **Application Driver** (Capybara and Kookaburra::APIClient)\r\n\r\n### The Business Specification Language ###\r\n\r\nThe business specification language consists of the highest-level descriptions\r\nof a feature that are suitable for sharing with the non/less-technical\r\nstakeholders on a project.\r\n\r\nGherkin is the external DSL used by Cucumber for this purpose, and you might\r\nhave the following scenario defined for an e-commerce application:\r\n\r\n    # purchase_items_in_cart.feature\r\n\r\n    Feature: Purchase Items in Cart\r\n\r\n      Scenario: Using Existing Billing and Shipping Information\r\n\r\n        Given I have an existing account\r\n        And I have previously specified default payment options\r\n        And I have previously specified default shipping options\r\n        And I have an item in my shopping cart\r\n\r\n        When I sign in to my account\r\n        And I choose to check out\r\n\r\n        Then I see my order summary\r\n        And I see that my default payment options will be used\r\n        And I see that my default shipping options will be used\r\n\r\nNote that the scenario is focused on business concepts versus interface details,\r\ni.e. you \"choose to check out\" rather than \"click on the checkout button\". If\r\nfor some reason your e-commerce system was going to be a terminal application\r\nrather than a web application, you would not need to change this scenario at\r\nall, because the actual business concepts described would not change (and\r\nalthough Kookaburra's focus is on testing web applications, it could likely be\r\nadapted to other environments.)\r\n\r\n### The Test Implementation ###\r\n\r\nThe Test Implementation layer exists as the line in between the Business\r\nSpecification Language and the Domain Driver, and it includes Cucumber step\r\ndefinitions, RSpec example blocks, Test::Unit tests, etc. At this layer, your\r\ncode orchestrates calls into the Domain Driver to mimic user interactions under\r\nvarious conditions and make assertions about the results.\r\n\r\n**Test assertions always belong within the test implementation layer.** Some\r\ntesting frameworks such as RSpec add methods like `#should` to `Object`, which\r\nhas the effect of poisoning the entire Ruby namespace with these methods---if\r\nyou are using RSpec, you can call `#should` anywhere in your code and it will\r\nwork when RSpec is loaded. Do not be tempted to call a testing library's Object\r\ndecorators anywhere outside of your test implementation (such as within\r\n`UIDriver` or `UIComponent` subclasses.) Doing so will tightly couple your\r\nDomain Driver and/or Window Driver implementation to a specific testing library.\r\n\r\n`Kookaburra::UIDriver::UIComponent` provides an `#assert` method for use inside\r\nyour own UIComponents. This method exists to verify preconditions and provide\r\nmore informative error messages; it is not intended to be used for test\r\nverifications.\r\n\r\n`Kookaburra::TestHelpers` provides a convenient way to make assertions about the\r\nmental model.  If you are using Test::Unit, see\r\n`Kookaburra::TestHelpers#assert_mental_model_of`; for RSpec, see\r\n`Kookaburra::TestHelpers#match_mental_model_of`.\r\n\r\nGiven the Cucumber scenario above, here is how the test implementation layer\r\nmight look:\r\n\r\n    # step_definitions/various_steps.rb\r\n\r\n    Given \"I have an existing account\" do\r\n      api.existing_account\r\n    end\r\n\r\n    Given \"I have previously specified default payment options\" do\r\n      api.default_payment_options_specified\r\n    end\r\n\r\n    Given \"I have previously specified default shipping options\" do\r\n      api.default_shipping_options_specified\r\n    end\r\n\r\n    Given \"I have an item in my shopping cart\" do\r\n      api.an_item_in_my_shopping_cart\r\n    end\r\n\r\n    When \"I sign in to my account\" do\r\n      ui.sign_in\r\n    end\r\n\r\n    When \"I choose to check out\" do\r\n      ui.choose_to_check_out\r\n    end\r\n\r\n    Then \"I see my order summary\" do\r\n      ui.order_summary.should be_visible\r\n    end\r\n\r\n    Then \"I see that my default payment options will be used\" do\r\n      ui.order_summary.payment_options.should match_mental_model_of(:default_payment_options)\r\n      # Or if you prefer Test::Unit style assertions...\r\n      # assert_mental_model_matches(:default_payment_options, ui.order_summary.payment_options)\r\n    end\r\n\r\n    Then \"I see that my default shipping options will be used\" do\r\n      ui.order_summary.shipping_options.should match_mental_model_of(:default_shipping_options)\r\n    end\r\n\r\nThe step definitions contain neither explicitly shared state (instance\r\nvariables) nor any logic branches; they are simply wrappers around calls into\r\nthe Domain Driver layer. There are a couple of advantages to this approach.\r\n\r\nFirst, because step definitions are so simple, it isn't necessary to force *Very\r\nSpecific Wording* on the business analyst/product owner who is writing the\r\nspecs. For instance, if she writes \"I see a summary of my order\" in another\r\nscenario, it's not a big deal to have the following in your step definitions (as\r\nlong as the author of the spec confirms that they really mean the same thing):\r\n\r\n    Then \"I see my order summary\" do\r\n      ui.order_summary.should be_visible\r\n    end\r\n\r\n    Then \"I see a summary of my order\" do\r\n      ui.order_summary.should be_visible\r\n    end\r\n\r\nThe step definitions are nothing more than a natural language reference to an\r\naction in the Domain Driver; there is no overwhelming maintenance cost to the\r\nslight duplication, and it opens up the capacity for more readable Gherkin\r\nspecs. The fewer false road blocks you put between your product owner and a\r\nwritten specification, the easier it becomes to ensure her participation in this\r\nprocess.\r\n\r\nThe second advantage is that by pushing all of the complexity down into the\r\nDomain Driver, it's now trivial to reuse the exact same code in\r\ndeveloper-centric integration tests. This ensures you have parity between the\r\nway the automated acceptance tests run and any additional testing that the\r\ndevelopment team needs to add in.\r\n\r\nUsing RSpec, the test implementation would be as follows:\r\n\r\n    # spec/integration/purchase_items_in_cart_spec.rb\r\n    \r\n    describe \"Purchase Items in Cart\" do\r\n      example \"Using Existing Billing and Shipping Information\" do\r\n        api.existing_account(:my_account)\r\n        api.default_payment_options_specified_for(:my_account)\r\n        api.default_shipping_options_specified_for(:my_account)\r\n        api.an_item_in_my_shopping_cart(:my_account)\r\n\r\n        ui.sign_in(:my_account)\r\n        ui.choose_to_check_out\r\n\r\n        ui.order_summary.should be_visible\r\n        ui.order_summary.payment_options.should == k.get_data(:default_payment_options)[:my_account]\r\n        ui.order_summary.shipping_options.should == k.get_data(:default_shipping_options)[:my_account]\r\n      end\r\n    end\r\n\r\n### The Domain Driver ###\r\n\r\nThe Domain Driver layer is where you build up an internal DSL that describes the\r\nbusiness concepts of your application at a fairly high level. It consists of two\r\ntop-level drivers: the `APIDriver` (available via `#api`) used to set up\r\nstate for your tests and the UIDriver (available via `#ui`) for describing the\r\ntasks that a user can accomplish with the application.\r\n\r\n#### Mental Model ####\r\n\r\n`Kookaburra::MentalModel` is the component via which the `APIDriver` and the\r\n`UIDriver` share information, and it is intended to represent your application\r\nuser's mental picture of the data they are working with. For instance, if you\r\ncreate a user account via the `APIDriver`, you would store the login\r\ncredentials for that account in the `MentalModel` instance, so the `UIDriver`\r\nknows what to use when you tell it to `#sign_in`. This is what allows the\r\nCucumber step definitions to remain free from explicitly shared state.\r\n\r\nKookaburra automatically configures your `APIDriver` and your `UIDriver` to\r\nshare a `MentalModel` instance, which is available to both of them via their\r\n`#mental_model` method.\r\n\r\nThe `MentalModel` instance will return a `MentalModel::Collection` for any method\r\ncalled on the object. The `MentalModel::Collection` object behaves like a `Hash`\r\nfor the most part; however, it will raise a `Kookaburra::UnknownKeyError` if you\r\ntry to access a key that has not yet been assigned a value.\r\n\r\nDeletions (via `#delete` or `#delete_if`) will actually remove the key/value\r\npair from the collection, but add it to a sub-collection (available at\r\n`MentalModel::Collection#deleted`). This reflects the fact that the user's\r\nmental model of the dataset would also include any intentional exceptions -\r\nthe user will, for example, want to verify that an item they deleted does\r\nnot appear to be available in the system.\r\n\r\nHere's an example of MentalModel behavior:\r\n\r\n    mental_model = MentalModel.new\r\n\r\n    mental_model.widgets[:widget_a] = {'name' => 'Widget A'}\r\n\r\n    mental_model.widgets[:widget_a]\r\n    #=> {'name' => 'Widget A'}\r\n\r\n    # this will raise a Kookaburra::UnknownKeyError\r\n    mental_model.widgets[:widget_b]\r\n\r\n    mental_model.widgets.delete(:widget_a)\r\n    #=> {'name' => 'Widget A'}\r\n\r\n    # this will now also raise a Kookaburra::UnknownKeyError...\r\n    mental_model.widgets[:widget_a]\r\n\r\n    # ...but the pair is now available here:\r\n    mental_model.widgets.deleted[:widget_a]\r\n    #=> {'name' => 'Widget A'}\r\n\r\n#### API Driver ####\r\n\r\nThe `Kookaburra::APIDriver` is used to create a particular \"preexisting\" state\r\nwithin your application's data and ensure you have a handle to that data (when\r\nneeded) prior to interacting with the UI. You will create a subclass of\r\n`Kookaburra::APIDriver` in which you will create part of the Domain Driver DSL\r\nfor your application:\r\n\r\n    # lib/my_app/kookaburra/api_driver.rb\r\n\r\n    class MyApp::Kookaburra::APIDriver < Kookaburra::APIDriver\r\n      # Specify the APIClient to use\r\n      def api\r\n        @api ||= MyApp::Kookaburra::APIClient.new(configuration)\r\n      end\r\n\r\n      def existing_account(nickname)\r\n        account_data = {'display_name' => 'John Doe', 'password' => 'a password'}\r\n        account_data['username'] = \"test-user-#{`uuidgen`.strip}\"\r\n\r\n        # use the API to create the account in the application\r\n        result = api.create_account(account_data)\r\n\r\n        # merge in the password, since API (hopefully!) doesn't return it, and\r\n        # store details in the MentalModel instance\r\n        result.merge!('password' => account_data['password'])\r\n        mental_model.accounts[nickname] = account_details\r\n      end\r\n    end\r\n\r\n#### API Client ####\r\n\r\nThe `Kookaburra::APIClient` is used to interact with an application's\r\nexternal web services API. You tell Kookaburra about your API by\r\ncreating a subclass of `Kookaburra::APIClient` for your application,\r\nspecifying how requests should be encoded and decoded, and specifying\r\nany headers that should be present on every request.\r\n\r\n    # lib/my_app/kookaburra/api_driver.rb\r\n\r\n    class MyApp::Kookaburra::APIClient < Kookaburra::APIClient\r\n      encode_with { |data| JSON.dump(data) }\r\n      decode_with { |data| JSON.parse(data) }\r\n      header 'Content-Type', 'application/json'\r\n      header 'Accept', 'application/json'\r\n\r\n      def create_account(account_data)\r\n        post '/api/accounts', account_data\r\n      end\r\n\r\n      def get_account(id)\r\n        get '/api/accounts/%d' % id\r\n      end\r\n    end\r\n\r\nThe content of your application's APIClient should consist mainly of\r\nmappings between discrete actions and HTTP requests to the specified URL\r\npaths.\r\n\r\n#### UI Driver ####\r\n\r\n`Kookaburra::UIDriver` provides the necessary tools for driving your\r\napplication's user interface with the Window Driver pattern. You will subclass\r\n`Kookaburra::UIDriver` for your application and implement your testing DSL\r\nwithin your subclass:\r\n\r\n    # lib/my_app/kookaburra/ui_driver.rb\r\n\r\n    class MyApp::Kookaburra::UIDriver < Kookaburra::UIDriver\r\n      # makes an instance of MyApp::Kookaburra::UIDriver::SignInScreen\r\n      # available via the instance method #sign_in_screen\r\n      ui_component :sign_in_screen, SignInScreen\r\n\r\n      def sign_in(account_nickname)\r\n        account = mental_model.accounts[account_nickname]\r\n        address_bar.go_to(sign_in_screen)\r\n        sign_in_screen.submit_login(account['username'], account['password'])\r\n      end\r\n    end\r\n\r\n### The Window Driver Layer ###\r\n\r\nWhile your `APIDriver` and `UIDriver` provide a DSL that represents actions\r\nyour users can perform in your application, the [Window Driver] [Window Driver]\r\nlayer describes the individual user interface components that the user interacts\r\nwith to perform these tasks. By describing each interface component using an OOP\r\napproach, it is much easier to maintain your acceptance/integration tests,\r\nbecause the implementation details of each component are captured in a single\r\nplace. For example, if/when the implementation of your application's sign in\r\nscreen changes, you can fix every single test that needs to log a user into the\r\nsystem just by updating the `SignInScreen` class.\r\n\r\nYou describe the various user interface components by sub-classing\r\n`Kookaburra::UIDriver::UIComponent`:\r\n\r\n    # lib/my_app/ui_driver/sign_in_screen.rb\r\n\r\n    class MyApp::Kookaburra::UIDriver::SignInScreen < Kookaburra::UIDriver::UIComponent\r\n      def component_locator\r\n        '#new_user_session'\r\n      end\r\n\r\n      def component_path\r\n        '/session/new'\r\n      end\r\n\r\n      def username\r\n        find('#session_username').value\r\n      end\r\n\r\n      def username=(new_value)\r\n        fill_in '#session_username', :with => new_value\r\n      end\r\n\r\n      def password\r\n        find('#session_password').value\r\n      end\r\n\r\n      def password=(new_value)\r\n        fill_in '#session_password', :with => new_value\r\n      end\r\n\r\n      def submit\r\n        click_on('Sign In')\r\n      end\r\n\r\n      def submit_login(username, password)\r\n        self.username = username\r\n        self.password = password\r\n        submit\r\n      end\r\n    end\r\n\r\n### The Application Driver Layer ###\r\n\r\n`Kookaburra::APIClient`, `Kookaburra::UIDriver` and\r\n`Kookaburra::UIDriver::UIComponent` rely on the Application Driver layer\r\nto interact with your application. In the case of the `APIClient`,\r\nKookaburra uses the [RestClient] [RestClient] library to send HTTP\r\nrequests to your application. The `UIDriver` and `UIComponent` rely on\r\nwhatever is passed to `Kookaburra.new` as the `:browser` option.\r\nPresently, we have only used Capybara as the application driver for\r\nKookaburra.\r\n\r\nIt's possible that something other than Capybara could be passed in, as long as\r\nthat something presented the same API. In reality, using something other than\r\nCapybara is likely to require some changes to Kookaburra itself. If you have a\r\nparticular interest in making this work, please feel free to fork the project\r\nand send us a [GitHub pull request] [Pull Request] with your changes.\r\n\r\n## Contributing to kookaburra ##\r\n \r\n* Check out the latest master to make sure the feature hasn't been implemented\r\n  or the bug hasn't been fixed yet\r\n* Check out the issue tracker to make sure someone already hasn't requested it\r\n  and/or contributed it\r\n* Fork the project\r\n* Start a feature/bugfix branch\r\n* Commit and push until you are happy with your contribution\r\n* Make sure to add tests for it. This is important so I don't break it in a\r\n  future version unintentionally.\r\n* Please try not to mess with the Rakefile, version, or history. If you want to\r\n  have your own version, or is otherwise necessary, that is fine, but please\r\n  isolate to its own commit so I can cherry-pick around it.\r\n* Send us a [pull request] [Pull Request]\r\n\r\n## Copyright ##\r\n\r\nCopyright &copy; 2011 John Wilger. See LICENSE.txt for\r\nfurther details.\r\n\r\n[Window Driver]: http://martinfowler.com/eaaDev/WindowDriver.html \"Window Driver - Martin Fowler\"\r\n[Kookaburra Gem]: https://rubygems.org/gems/kookaburra \"kookaburra | RubyGems.org | your community gem host\"\r\n[Rack]: http://rack.rubyforge.org/ \"Rack: a Ruby Webserver Interface\"\r\n[Capybara]: https://github.com/jnicklas/capybara \"jnicklas/capybara - GitHub\"\r\n[RSpec]: http://rspec.info \"RSpec.info: home\"\r\n[Cucumber]: http://cukes.info/ \"Cucumber - Making BDD fun\"\r\n[Pull Request]: https://github.com/projectdx/kookaburra/pull/new/master \"Send a pull request - GitHub\"\r\n[RestClient]: https://github.com/archiloque/rest-client \"archiloque/rest-client -GitHub\"\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}